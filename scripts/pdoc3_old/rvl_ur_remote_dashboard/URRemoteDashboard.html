<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>rvl_ur_remote_dashboard.URRemoteDashboard API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rvl_ur_remote_dashboard.URRemoteDashboard</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># rospy
import rospy
import rosservice
from rospy import ServiceException, ROSException
from rospy.exceptions import ROSInterruptException

# typing and type hinting
from typing import Union

# pretty logging
from rvl_utilities.CustomLogger import ColorLogger
from pprint import pprint

# Additional UR mappings
# from ur_dashboard_msgs.msg import ProgramState
from rvl_ur_remote_dashboard.URInterfaceMapping import *

# Robotiq driver
from rvl_robotiq_controller.RobotiqController import Robotiq2FController

class URRemoteDashboard:
    def __init__(self, name: str = &#39;UR5e&#39;, using_gripper: bool = False, using_urscript: bool = False, service_timeout: int = 5) -&gt; None:
        &#34;&#34;&#34;The UR Remote Dashboard class. This is the primary extension overlaying the existing
        Universal Robot Driver code base to access mapped services.

        Args:
            name (str, optional): Readable name to identify controller. Defaults to &#39;UR5e&#39;.
            using_gripper (bool, optional): Initialized the attached Robotiq gripper. Defaults to False.
            using_urscript (bool, optional): Register appropriate publisher to send UR Script. Defaults to False.
            service_timeout (int, optional): Wait time for services to come on. Defaults to 5.
        &#34;&#34;&#34;

        # custom logger
        self.logger = ColorLogger(name + &#39; Remote Dashboard&#39;)

        # default service timeout
        self.service_timeout = service_timeout

        # robot status tracking
        self.robot_mode = None
        self.safety_mode = None
        self.last_known_io_states = None
        self.loaded_program = None
        self.using_urscript = False

        # services
        self.services = self.define_services()

        # publisher/subscriber
        self.register_robot_status()
        
        # extended features
        if using_gripper:
            raise NotImplementedError
        
        if using_urscript:
            raise NotImplementedError

    # ---------------------------------------------------------------------------- #
    #                                 POWER CONTROL                                #
    # ---------------------------------------------------------------------------- #

    def power_on_arm(self, timeout: int = 30) -&gt; bool:
        &#34;&#34;&#34;Power on the arm to idle state (brakes engaged).&#34;&#34;&#34;
        success = self.trigger_service(&#39;power_on&#39;)
        if success:
            self.logger.log_warn(f&#39;Waiting for arm to power on&#39;)
            try:
                elapsed = 0
                while self.robot_mode &lt; 5 and elapsed &lt; timeout and not rospy.is_shutdown():
                    rospy.sleep(1)
                    elapsed += 1
                    if elapsed &gt; timeout:
                        raise ROSException
                self.logger.log_success(&#39;Arm powered on (brakes engaged)&#39;)
                return True
            except ROSException as e:
                self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds power on time. Aborted.&#39;)
                return False
        else:
            self.logger.log_error(&#39;Unable to power on robot arm&#39;)
            return False

    def power_off_arm(self, timeout: int = 30) -&gt; bool:
        &#34;&#34;&#34;Power off the arm.&#34;&#34;&#34;
        success = self.trigger_service(&#39;power_off&#39;)
        if success:
            self.logger.log_warn(f&#39;Waiting for arm to power off&#39;)
            try:
                elapsed = 0
                while self.robot_mode &gt; 3 and elapsed &lt; timeout and not rospy.is_shutdown():
                    rospy.sleep(1)
                    elapsed += 1
                    if elapsed &gt; timeout:
                        raise ROSException
                self.logger.log_success(&#39;Arm powered off&#39;)
                return True
            except ROSException as e:
                self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds power off time. Aborted.&#39;)
                return False
        else:
            self.logger.log_error(&#39;Unable to power off robot arm&#39;)
            return False

    def system_shutdown(self) -&gt; None:
        &#34;&#34;&#34;Fully power down the robot (including control box).&#34;&#34;&#34;
        _ = self.trigger_service(&#39;shutdown&#39;)
        # rospy.signal_shutdown(&#39;UR System shutdown requested. Shutting everything down.&#39;)
        self.logger.log_success(&#39;Goodbye!&#39;)

    def cold_boot(self) -&gt; bool:
        &#34;&#34;&#34;Go directly to operational state (power on, brakes released). See release_brakes().&#34;&#34;&#34;
        return self.release_brakes()

    # ---------------------------------------------------------------------------- #
    #                                SAFETY CONTROL                                #
    # ---------------------------------------------------------------------------- #

    def release_brakes(self, timeout: int = 30) -&gt; bool:
        &#34;&#34;&#34;Fully power on the robot with brakes released.&#34;&#34;&#34;
        success = self.trigger_service(&#39;brake_release&#39;)
        if success:
            self.logger.log_warn(f&#39;Waiting for arm to power on and release brakes&#39;)
            try:
                elapsed = 0
                while self.robot_mode &lt; 7 and elapsed &lt; timeout and not rospy.is_shutdown():
                    rospy.sleep(1)
                    elapsed += 1
                    if elapsed &gt; timeout:
                        raise ROSException
                self.logger.log_success(&#39;Arm powered and ready for planning!&#39;)
                return True
            except ROSException as _:
                self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds full powered on time. Aborted.&#39;)
                return False
        else:
            self.logger.log_error(&#39;Unable to fully initialized robot&#39;)
            return False

    def restart_safety(self) -&gt; bool:
        &#34;&#34;&#34;Clear a safety fault or violation. Arm will be powered off.&#34;&#34;&#34;
        success = self.trigger_service(&#39;restart_safety&#39;)
        if success:
            self.logger.log_warn(f&#39;Safety fault/violation cleared&#39;)
            self.logger.log_warn(f&#39;Robot is now powered off&#39;)
            self.logger.log_error(f&#39;Check log for additional information before restarting!&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to clear safety violation&#39;)
            return False

    def clear_protective_stop(self, timeout: int = 30) -&gt; bool:
        &#34;&#34;&#34;Clear a protective stop.&#34;&#34;&#34;
        success = self.trigger_service(&#39;unlock_protective_stop&#39;)
        if success:
            self.logger.log_warn(f&#39;Waiting for protective stop to clear&#39;)
            try:
                elapsed = 0
                while self.safety_mode != 1 and elapsed &lt; timeout and not rospy.is_shutdown():
                    rospy.sleep(1)
                    elapsed += 1
                    if elapsed &gt; timeout:
                        raise ROSException
                self.logger.log_success(&#39;Protective stop cleared&#39;)
                return True
            except ROSException as _:
                self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds clearing time. Aborted.&#39;)
                return False
        else:
            self.logger.log_error(&#39;Unable to clear protective stop&#39;)
            return False

    def clear_operational_mode(self) -&gt; bool:
        &#34;&#34;&#34;Allow PolyScope to change operational mode. User password will be enabled.&#34;&#34;&#34;
        success = self.trigger_service(&#39;clear_operational_mode&#39;)
        if success:
            self.logger.log_warn(f&#39;Operational mode cleared&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to clear operational mode&#39;)
            return False

    # ---------------------------------------------------------------------------- #
    #                                 POPUP CONTROL                                #
    # ---------------------------------------------------------------------------- #

    def close_popup(self, safety: bool = False) -&gt; bool:
        &#34;&#34;&#34;Close a popup on the Teach Pendant or PolyScope.

        Args:
            safety (bool, optional): Set to True if popup is a safety popup. Defaults to False.

        Returns:
            bool: True if the targeted popup is closed.
        &#34;&#34;&#34;
        if safety:
            success = self.trigger_service(&#39;close_safety_popup&#39;)
        else:
            success = self.trigger_service(&#39;close_popup&#39;)

        if success:
            self.logger.log_success(f&#39;{&#34;Safety popup&#34; if safety else &#34;Popup&#34;} closed&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to close popup&#39;)
            return False

    def send_popup(self, message: str) -&gt; bool:
        &#34;&#34;&#34;Send a message as a popup to Teach Pendant or PolyScope.&#34;&#34;&#34;
        request = PopupRequest()
        request.message = message
        try:
            serv = self.services[&#39;popup&#39;]
            rospy.wait_for_message(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, Popup)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(&#39;Popup sent to Teach Pendant&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to send popup&#39;)
            self.logger.log_error(e)
            return False

    # ---------------------------------------------------------------------------- #
    #                           DASHBOARD SERVER CONTROL                           #
    # ---------------------------------------------------------------------------- #

    def connect_dashboard(self, quiet: bool = False) -&gt; bool:
        &#34;&#34;&#34;Connect to the dashboard server. Need to be done before calling other services.&#34;&#34;&#34;
        success = self.trigger_service(&#39;connect&#39;)
        if success:
            self.logger.log_success(&#39;Connection to dashboard established&#39;)
            return True
        else:
            if not quiet:
                self.logger.log_error(&#39;Unable to disconnect from dashboard server&#39;)
            return False

    def disconnect_dashboard(self) -&gt; bool:
        &#34;&#34;&#34;Disconnect from the dashboard server.&#34;&#34;&#34;
        success = self.trigger_service(&#39;quit&#39;)
        if success:
            self.logger.log_success(&#39;Connection to dashboard terminated&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to disconnect from dashboard server&#39;)
            return False

    def spam_connect(self, attempts: int = 10) -&gt; bool:
        &#34;&#34;&#34;Repeatedly calling connect() due to error prone and asynchronous status of the server.
        
        Args:
            attempts (int, optional): Number of times connect() is called internally. Defaults to 10.
        &#34;&#34;&#34;
        for i in range(attempts):
            self.logger.log_warn(f&#39;Reconnecting attempted ({attempts - i} remaining)&#39;, indent = 1)
            if self.connect_dashboard(quiet = True):
                return True
            rospy.sleep(1)
        self.logger.log_error(&#39;Reconnection attempts to dashboard server unsuccessful&#39;)
        return False

    # ---------------------------------------------------------------------------- #
    #                    POLYSCOPE PROGRAMS/INSTALLATION CONTROL                   #
    # ---------------------------------------------------------------------------- #

    def start_loaded_program(self) -&gt; bool:
        &#34;&#34;&#34;Start execution of default or loaded program.&#34;&#34;&#34;
        success = self.trigger_service(&#39;play&#39;)
        if success:
            self.logger.log_success(f&#39;Program {self.loaded_program} is running&#39;)
            return True
        else:
            self.logger.log_error(f&#39;Unable to start {self.loaded_program}&#39;)
            return False

    def pause_loaded_program(self) -&gt; bool:
        &#34;&#34;&#34;Pause PolyScope program execution.&#34;&#34;&#34;
        success = self.trigger_service(&#39;pause&#39;)
        if success:
            self.logger.log_success(f&#39;Program {self.loaded_program} is paused&#39;)
            return True
        else:
            self.logger.log_error(f&#39;Unable to pause {self.loaded_program}&#39;)

            return False

    def stop_loaded_program(self) -&gt; bool:
        &#34;&#34;&#34;Stop PolyScope program execution.&#34;&#34;&#34;
        success = self.trigger_service(&#39;stop&#39;)
        if success:
            self.logger.log_success(f&#39;Program {self.loaded_program} is stopped&#39;)
            return True
        else:
            self.logger.log_error(f&#39;Unable to stop {self.loaded_program}&#39;)
            return False

    def is_program_running(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the default or loaded program is running.&#34;&#34;&#34;
        try:
            response = rospy.ServiceProxy(self.services[&#39;program_running&#39;], IsProgramRunning)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(f&#39;Program &#34;{self.loaded_program}&#34; is {&#34;running&#34; if response.program_running else &#34;not running&#34;}&#39;)
            return response.program_running
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to query if program is running&#39;)
            self.logger.log_error(e)
            return False

    def is_program_saved(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the default or loaded program is saved.&#34;&#34;&#34;
        try:
            response = rospy.ServiceProxy(self.services[&#39;program_saved&#39;], IsProgramSaved)()
            self.logger.log_success(f&#39;Program &#34;{response.program_name}&#34; is {&#34;saved&#34; if response.program_saved else &#34;not saved&#34;}&#39;)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            return response.program_saved
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to query if program is saved&#39;)
            self.logger.log_error(e)
            return False

    def query_program_state(self) -&gt; None:
        &#34;&#34;&#34;Display the name and execution state of the current PolyScope program.&#34;&#34;&#34;
        try:
            response = rospy.ServiceProxy(self.services[&#39;program_state&#39;], GetProgramState)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(f&#39;Program &#34;{response.program_name}&#34; state is {response.state.state}&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to query if program is saved&#39;)
            self.logger.log_error(e)

    def terminate_external_control(self) -&gt; bool:
        &#34;&#34;&#34;Make the external_control node on PolyScope returns.&#34;&#34;&#34;
        success = self.trigger_service(&#39;hand_back_control&#39;)
        if success:
            self.logger.log_success(&#39;&#34;External Control&#34; program node terminated&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to terminate external control node&#39;)
            return False

    def get_loaded_program(self) -&gt; Union[str, None]:
        &#34;&#34;&#34;Returns the name of the loaded program.&#34;&#34;&#34;
        try:
            serv = self.services[&#39;get_loaded_program&#39;]
            response = rospy.ServiceProxy(serv, GetLoadedProgram)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.loaded_program = response.program_name
            return response.program_name
        except Exception as e:
            self.logger.log_error(&#39;Unable to request loaded program name&#39;)
            self.logger.log_error(str(e))

    def load_program(self, filename: str, ptype: str, wait: int = 10, attempts: int = 10) -&gt; None:
        &#34;&#34;&#34;Load a program or installation file.

        Args:
            filename (str): Name of file with extension e.g., program.urp
            ptype (str): Type of program. Accepting [&#39;prog&#39;, &#39;p&#39;, &#39;program&#39;, &#39;urp&#39;] or [&#39;inst&#39;, &#39;i&#39;, &#39;installation&#39;].
            wait (int, optional): Wait time to handle known disconnection issue. Defaults to 10.
            attempts (int, optional): Number of reconnection attempts. Defaults to 10.
        &#34;&#34;&#34;
        request = LoadRequest()
        request.filename = filename
        try:
            if ptype in [&#39;prog&#39;, &#39;p&#39;, &#39;program&#39;, &#39;urp&#39;]:
                serv = self.services[&#39;load_program&#39;]
            elif ptype in [&#39;inst&#39;, &#39;i&#39;, &#39;installation&#39;]:
                serv = self.services[&#39;load_installation&#39;]
            else:
                self.logger.log_error(f&#39;{ptype} is invalid&#39;)
                self.logger.log_error(f&#39;Expecting program [p, prog, program, urp] or installation [inst, i, installation]&#39;)
                return None
            rospy.wait_for_service(serv, timeout=self.service_timeout)
            response = rospy.ServiceProxy(serv, Load)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        except (ServiceException, ROSException) as _:
            self.logger.log_warn(&#39;Known dashboard server disconnection occured&#39;)
            self.logger.log_warn(f&#39;Waiting for {wait} seconds for program/installation to load correctly&#39;)
            rospy.sleep(wait)
            self.logger.log_warn(f&#39;Attempting to reconnect to dashboard server ({attempts} attempts)&#39;)
            self.spam_connect(attempts = attempts)
            self.close_popup()
            self.cold_boot()
        except KeyError as e:
            self.logger.log_error(str(e))
            return None
        self.last_known_installation = filename
        rospy.sleep(1)

    # ---------------------------------------------------------------------------- #
    #                                 ROBOT STATUS                                 #
    # ---------------------------------------------------------------------------- #

    def robot_status_callback(self, msg):
        self.robot_mode = msg.mode

    def robot_safety_callback(self, msg):
        self.safety_mode = msg.mode

    def robot_iostate_callback(self, msg):
        self.last_known_io_states = msg

    def get_robot_mode(self) -&gt; Union[int, None]:
        &#34;&#34;&#34;Returns the current robot mode.&#34;&#34;&#34;
        try:
            serv = self.services[&#39;get_robot_mode&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, GetRobotMode)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            mode = response.robot_mode.mode
            self.logger.log_success(f&#39;Robot mode = {mode} ({RobotModeMapping(mode).name})&#39;)
            return mode
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to request robot mode&#39;)
            self.logger.log_error(e)
        
    def get_safety_mode(self) -&gt; Union[int, None]:
        &#34;&#34;&#34;Returns the current safety mode.&#34;&#34;&#34;
        try:
            serv = self.services[&#39;get_safety_mode&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, GetSafetyMode)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            mode = response.safety_mode.mode
            self.logger.log_success(f&#39;Robot safety mode = {mode} ({SafetyModeMapping(mode).name})&#39;)
            return mode
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to request robot safety mode&#39;)
            self.logger.log_error(e)

    # ---------------------------------------------------------------------------- #
    #                               ADVANCED FEATURES                              #
    # ---------------------------------------------------------------------------- #

    def zero_force_torque_sensor(self) -&gt; bool:
        &#34;&#34;&#34;Zero the ft-sensor. Only work on e-Series in remote-control mode.&#34;&#34;&#34;
        success = self.trigger_service(&#39;zero_ftsensor&#39;)
        if success:
            self.logger.log_success(&#39;Force/Torque sensor zero-ed&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to zero force/torque sensor&#39;)
            return False

    def log_to_pendant(self, message: str) -&gt; None:
        &#34;&#34;&#34;Log a message to PolyScope logs.&#34;&#34;&#34;
        request = AddToLogRequest()
        request.message = message
        try:
            serv = self.services[&#39;add_to_log&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, AddToLog)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to log message to Teach Pendant&#39;)
            self.logger.log_error(e)

    def raw_request(self, query):
        &#34;&#34;&#34;Send any arbitrary message or request to the dashboard server.&#34;&#34;&#34;
        request = RawRequestRequest()
        request.query = query
        try:
            serv = self.services[&#39;raw_request&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, RawRequest)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to log message to Teach Pendant&#39;)
            self.logger.log_error(e)

    def set_io(self, function: int, pin: int, state: float) -&gt; None:
        &#34;&#34;&#34;Set specific IO port on the robot. Currently not supporting specific domains (current/voltage).

        Args:
            function (int): See SetIOFunctionMapping.
            pin (int): Which pin to execute the function on.
            state (float): 0/1 for digital IOs and value for analog IO.
        &#34;&#34;&#34;
        request = SetIORequest()
        request.fun = function
        request.pin = pin
        request.state = state
        try:
            serv = self.services[&#39;set_io&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, SetIO)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(f&#39;Unable to set pin {pin} to {state} using {SetIOFunctionMapping(function).name}&#39;)
            self.logger.log_error(e)

    def set_payload(self, mass: float, cx: float, cy: float, cz: float) -&gt; None:
        &#34;&#34;&#34;Set the payload mass and center of gravity.

        Args:
            mass (float): Mass of the payload in kg.
            cx, cy, cz (float): Center of gravity of the payload.
        &#34;&#34;&#34;
        request = SetPayloadRequest()
        request.center_of_gravity = Vector3()
        request.center_of_gravity.x = cx
        request.center_of_gravity.y = cy
        request.center_of_gravity.z = cz
        request.mass = mass
        try:
            serv = self.services[&#39;set_payload&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, SetPayload)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(f&#39;Setting payload successfully&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to set payload&#39;)
            self.logger.log_error(e)

    def set_speed_slider(self, fraction: float) -&gt; None:
        &#34;&#34;&#34;Set robot execution speed as a fraction. Only set less than 1 on scaled controllers.

        Args:
            fraction (float): 0 to 1 if using scaled (default) controllers.
        &#34;&#34;&#34;
        request = SetSpeedSliderFractionRequest()
        request.speed_slider_fraction = clip(fraction, 0.0, 1.0)
        try:
            serv = self.services[&#39;set_speed_slider&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, SetSpeedSliderFraction)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(f&#39;Setting speed slider successfully&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to set speed slider&#39;)
            self.logger.log_error(e)

    # def set_robot_mode(self):
    #     raise NotImplementedError

    # ---------------------------------------------------------------------------- #
    #                             SUPPORTING FUNCTIONS                             #
    # ---------------------------------------------------------------------------- #

    def trigger_service(self, serv_alias):
        &#34;&#34;&#34;Internal trigger service handling with exceptions&#34;&#34;&#34;
        if serv_alias in self.services:
            serv_name = self.services[serv_alias]
            try:
                rospy.wait_for_service(serv_name, timeout = self.service_timeout)
                response = rospy.ServiceProxy(serv_name, Trigger)()
                if not response.success:
                    self.logger.log_error(response.message)
                    raise ServiceException(&#39;response.success returned False&#39;)
                return response.success
            except (ROSException, ROSInterruptException, KeyboardInterrupt, ServiceException) as e:
                self.logger.log_error(f&#39;Unable to trigger {serv_name}&#39;)
                self.logger.log_error(e)
        else:
            self.logger.log_error(f&#39;{serv_alias} is unknown/unsupported. Aborted.&#39;)
            return False

    def define_services(self):
        available = rosservice.get_service_list()
        filterted = [s for s in available if &#39;ur_hardware_interface&#39; in s and &#39;logger&#39; not in s]
        services = {s[s.rfind(&#39;/&#39;) + 1:] : s for s in filterted}
        return dict(sorted(services.items()))

    def register_robot_status(self) -&gt; None:
        &#34;&#34;&#34;Register necessary subscribers and callbacks to monitor robot operational status.&#34;&#34;&#34;
        try:
            # wait for topics to show up
            self.robot_mode = rospy.wait_for_message(&#39;/ur_hardware_interface/robot_mode&#39;, RobotMode, timeout = self.service_timeout).mode
            self.safety_mode = rospy.wait_for_message(&#39;/ur_hardware_interface/safety_mode&#39;, SafetyMode, timeout = self.service_timeout).mode
            self.last_known_io_states = rospy.wait_for_message(&#39;/ur_hardware_interface/io_states&#39;, IOStates, timeout = self.service_timeout)

            # register robot status tracking with callbacks
            self.robot_mode_sub = rospy.Subscriber(&#39;/ur_hardware_interface/robot_mode&#39;, RobotMode, self.robot_status_callback)
            self.robot_safety_sub = rospy.Subscriber(&#39;/ur_hardware_interface/safety&#39;, SafetyMode, self.robot_safety_callback)
            self.robot_io_sub = rospy.Subscriber(&#39;/ur_hardware_interface/io_states&#39;, IOStates, self.robot_iostate_callback)

            # verify if services are available
            self.verify_services()

            # get program name
            self.get_loaded_program()

            self.logger.log_success(&#39;Registered robot status subscribers&#39;)
        except ROSException as error:
            self.logger.log_error(&#39;Unable to register status subscriber&#39;)
            self.logger.log_error(&#39;Remote Dashboard terminated&#39;)
            self.logger.log_error(error)
            exit(-1)

    def verify_services(self):
        self.logger.log_warn(&#39;Validating if all services are available&#39;)
        for _, serv in self.services.items():
            rospy.wait_for_service(serv, timeout = self.service_timeout)
        self.logger.log_success(&#39;All supported services are available&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard"><code class="flex name class">
<span>class <span class="ident">URRemoteDashboard</span></span>
<span>(</span><span>name: str = 'UR5e', using_gripper: bool = False, using_urscript: bool = False, service_timeout: int = 5)</span>
</code></dt>
<dd>
<div class="desc"><p>The UR Remote Dashboard class. This is the primary extension overlaying the existing
Universal Robot Driver code base to access mapped services.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Readable name to identify controller. Defaults to 'UR5e'.</dd>
<dt><strong><code>using_gripper</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Initialized the attached Robotiq gripper. Defaults to False.</dd>
<dt><strong><code>using_urscript</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Register appropriate publisher to send UR Script. Defaults to False.</dd>
<dt><strong><code>service_timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Wait time for services to come on. Defaults to 5.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class URRemoteDashboard:
    def __init__(self, name: str = &#39;UR5e&#39;, using_gripper: bool = False, using_urscript: bool = False, service_timeout: int = 5) -&gt; None:
        &#34;&#34;&#34;The UR Remote Dashboard class. This is the primary extension overlaying the existing
        Universal Robot Driver code base to access mapped services.

        Args:
            name (str, optional): Readable name to identify controller. Defaults to &#39;UR5e&#39;.
            using_gripper (bool, optional): Initialized the attached Robotiq gripper. Defaults to False.
            using_urscript (bool, optional): Register appropriate publisher to send UR Script. Defaults to False.
            service_timeout (int, optional): Wait time for services to come on. Defaults to 5.
        &#34;&#34;&#34;

        # custom logger
        self.logger = ColorLogger(name + &#39; Remote Dashboard&#39;)

        # default service timeout
        self.service_timeout = service_timeout

        # robot status tracking
        self.robot_mode = None
        self.safety_mode = None
        self.last_known_io_states = None
        self.loaded_program = None
        self.using_urscript = False

        # services
        self.services = self.define_services()

        # publisher/subscriber
        self.register_robot_status()
        
        # extended features
        if using_gripper:
            raise NotImplementedError
        
        if using_urscript:
            raise NotImplementedError

    # ---------------------------------------------------------------------------- #
    #                                 POWER CONTROL                                #
    # ---------------------------------------------------------------------------- #

    def power_on_arm(self, timeout: int = 30) -&gt; bool:
        &#34;&#34;&#34;Power on the arm to idle state (brakes engaged).&#34;&#34;&#34;
        success = self.trigger_service(&#39;power_on&#39;)
        if success:
            self.logger.log_warn(f&#39;Waiting for arm to power on&#39;)
            try:
                elapsed = 0
                while self.robot_mode &lt; 5 and elapsed &lt; timeout and not rospy.is_shutdown():
                    rospy.sleep(1)
                    elapsed += 1
                    if elapsed &gt; timeout:
                        raise ROSException
                self.logger.log_success(&#39;Arm powered on (brakes engaged)&#39;)
                return True
            except ROSException as e:
                self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds power on time. Aborted.&#39;)
                return False
        else:
            self.logger.log_error(&#39;Unable to power on robot arm&#39;)
            return False

    def power_off_arm(self, timeout: int = 30) -&gt; bool:
        &#34;&#34;&#34;Power off the arm.&#34;&#34;&#34;
        success = self.trigger_service(&#39;power_off&#39;)
        if success:
            self.logger.log_warn(f&#39;Waiting for arm to power off&#39;)
            try:
                elapsed = 0
                while self.robot_mode &gt; 3 and elapsed &lt; timeout and not rospy.is_shutdown():
                    rospy.sleep(1)
                    elapsed += 1
                    if elapsed &gt; timeout:
                        raise ROSException
                self.logger.log_success(&#39;Arm powered off&#39;)
                return True
            except ROSException as e:
                self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds power off time. Aborted.&#39;)
                return False
        else:
            self.logger.log_error(&#39;Unable to power off robot arm&#39;)
            return False

    def system_shutdown(self) -&gt; None:
        &#34;&#34;&#34;Fully power down the robot (including control box).&#34;&#34;&#34;
        _ = self.trigger_service(&#39;shutdown&#39;)
        # rospy.signal_shutdown(&#39;UR System shutdown requested. Shutting everything down.&#39;)
        self.logger.log_success(&#39;Goodbye!&#39;)

    def cold_boot(self) -&gt; bool:
        &#34;&#34;&#34;Go directly to operational state (power on, brakes released). See release_brakes().&#34;&#34;&#34;
        return self.release_brakes()

    # ---------------------------------------------------------------------------- #
    #                                SAFETY CONTROL                                #
    # ---------------------------------------------------------------------------- #

    def release_brakes(self, timeout: int = 30) -&gt; bool:
        &#34;&#34;&#34;Fully power on the robot with brakes released.&#34;&#34;&#34;
        success = self.trigger_service(&#39;brake_release&#39;)
        if success:
            self.logger.log_warn(f&#39;Waiting for arm to power on and release brakes&#39;)
            try:
                elapsed = 0
                while self.robot_mode &lt; 7 and elapsed &lt; timeout and not rospy.is_shutdown():
                    rospy.sleep(1)
                    elapsed += 1
                    if elapsed &gt; timeout:
                        raise ROSException
                self.logger.log_success(&#39;Arm powered and ready for planning!&#39;)
                return True
            except ROSException as _:
                self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds full powered on time. Aborted.&#39;)
                return False
        else:
            self.logger.log_error(&#39;Unable to fully initialized robot&#39;)
            return False

    def restart_safety(self) -&gt; bool:
        &#34;&#34;&#34;Clear a safety fault or violation. Arm will be powered off.&#34;&#34;&#34;
        success = self.trigger_service(&#39;restart_safety&#39;)
        if success:
            self.logger.log_warn(f&#39;Safety fault/violation cleared&#39;)
            self.logger.log_warn(f&#39;Robot is now powered off&#39;)
            self.logger.log_error(f&#39;Check log for additional information before restarting!&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to clear safety violation&#39;)
            return False

    def clear_protective_stop(self, timeout: int = 30) -&gt; bool:
        &#34;&#34;&#34;Clear a protective stop.&#34;&#34;&#34;
        success = self.trigger_service(&#39;unlock_protective_stop&#39;)
        if success:
            self.logger.log_warn(f&#39;Waiting for protective stop to clear&#39;)
            try:
                elapsed = 0
                while self.safety_mode != 1 and elapsed &lt; timeout and not rospy.is_shutdown():
                    rospy.sleep(1)
                    elapsed += 1
                    if elapsed &gt; timeout:
                        raise ROSException
                self.logger.log_success(&#39;Protective stop cleared&#39;)
                return True
            except ROSException as _:
                self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds clearing time. Aborted.&#39;)
                return False
        else:
            self.logger.log_error(&#39;Unable to clear protective stop&#39;)
            return False

    def clear_operational_mode(self) -&gt; bool:
        &#34;&#34;&#34;Allow PolyScope to change operational mode. User password will be enabled.&#34;&#34;&#34;
        success = self.trigger_service(&#39;clear_operational_mode&#39;)
        if success:
            self.logger.log_warn(f&#39;Operational mode cleared&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to clear operational mode&#39;)
            return False

    # ---------------------------------------------------------------------------- #
    #                                 POPUP CONTROL                                #
    # ---------------------------------------------------------------------------- #

    def close_popup(self, safety: bool = False) -&gt; bool:
        &#34;&#34;&#34;Close a popup on the Teach Pendant or PolyScope.

        Args:
            safety (bool, optional): Set to True if popup is a safety popup. Defaults to False.

        Returns:
            bool: True if the targeted popup is closed.
        &#34;&#34;&#34;
        if safety:
            success = self.trigger_service(&#39;close_safety_popup&#39;)
        else:
            success = self.trigger_service(&#39;close_popup&#39;)

        if success:
            self.logger.log_success(f&#39;{&#34;Safety popup&#34; if safety else &#34;Popup&#34;} closed&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to close popup&#39;)
            return False

    def send_popup(self, message: str) -&gt; bool:
        &#34;&#34;&#34;Send a message as a popup to Teach Pendant or PolyScope.&#34;&#34;&#34;
        request = PopupRequest()
        request.message = message
        try:
            serv = self.services[&#39;popup&#39;]
            rospy.wait_for_message(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, Popup)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(&#39;Popup sent to Teach Pendant&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to send popup&#39;)
            self.logger.log_error(e)
            return False

    # ---------------------------------------------------------------------------- #
    #                           DASHBOARD SERVER CONTROL                           #
    # ---------------------------------------------------------------------------- #

    def connect_dashboard(self, quiet: bool = False) -&gt; bool:
        &#34;&#34;&#34;Connect to the dashboard server. Need to be done before calling other services.&#34;&#34;&#34;
        success = self.trigger_service(&#39;connect&#39;)
        if success:
            self.logger.log_success(&#39;Connection to dashboard established&#39;)
            return True
        else:
            if not quiet:
                self.logger.log_error(&#39;Unable to disconnect from dashboard server&#39;)
            return False

    def disconnect_dashboard(self) -&gt; bool:
        &#34;&#34;&#34;Disconnect from the dashboard server.&#34;&#34;&#34;
        success = self.trigger_service(&#39;quit&#39;)
        if success:
            self.logger.log_success(&#39;Connection to dashboard terminated&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to disconnect from dashboard server&#39;)
            return False

    def spam_connect(self, attempts: int = 10) -&gt; bool:
        &#34;&#34;&#34;Repeatedly calling connect() due to error prone and asynchronous status of the server.
        
        Args:
            attempts (int, optional): Number of times connect() is called internally. Defaults to 10.
        &#34;&#34;&#34;
        for i in range(attempts):
            self.logger.log_warn(f&#39;Reconnecting attempted ({attempts - i} remaining)&#39;, indent = 1)
            if self.connect_dashboard(quiet = True):
                return True
            rospy.sleep(1)
        self.logger.log_error(&#39;Reconnection attempts to dashboard server unsuccessful&#39;)
        return False

    # ---------------------------------------------------------------------------- #
    #                    POLYSCOPE PROGRAMS/INSTALLATION CONTROL                   #
    # ---------------------------------------------------------------------------- #

    def start_loaded_program(self) -&gt; bool:
        &#34;&#34;&#34;Start execution of default or loaded program.&#34;&#34;&#34;
        success = self.trigger_service(&#39;play&#39;)
        if success:
            self.logger.log_success(f&#39;Program {self.loaded_program} is running&#39;)
            return True
        else:
            self.logger.log_error(f&#39;Unable to start {self.loaded_program}&#39;)
            return False

    def pause_loaded_program(self) -&gt; bool:
        &#34;&#34;&#34;Pause PolyScope program execution.&#34;&#34;&#34;
        success = self.trigger_service(&#39;pause&#39;)
        if success:
            self.logger.log_success(f&#39;Program {self.loaded_program} is paused&#39;)
            return True
        else:
            self.logger.log_error(f&#39;Unable to pause {self.loaded_program}&#39;)

            return False

    def stop_loaded_program(self) -&gt; bool:
        &#34;&#34;&#34;Stop PolyScope program execution.&#34;&#34;&#34;
        success = self.trigger_service(&#39;stop&#39;)
        if success:
            self.logger.log_success(f&#39;Program {self.loaded_program} is stopped&#39;)
            return True
        else:
            self.logger.log_error(f&#39;Unable to stop {self.loaded_program}&#39;)
            return False

    def is_program_running(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the default or loaded program is running.&#34;&#34;&#34;
        try:
            response = rospy.ServiceProxy(self.services[&#39;program_running&#39;], IsProgramRunning)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(f&#39;Program &#34;{self.loaded_program}&#34; is {&#34;running&#34; if response.program_running else &#34;not running&#34;}&#39;)
            return response.program_running
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to query if program is running&#39;)
            self.logger.log_error(e)
            return False

    def is_program_saved(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the default or loaded program is saved.&#34;&#34;&#34;
        try:
            response = rospy.ServiceProxy(self.services[&#39;program_saved&#39;], IsProgramSaved)()
            self.logger.log_success(f&#39;Program &#34;{response.program_name}&#34; is {&#34;saved&#34; if response.program_saved else &#34;not saved&#34;}&#39;)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            return response.program_saved
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to query if program is saved&#39;)
            self.logger.log_error(e)
            return False

    def query_program_state(self) -&gt; None:
        &#34;&#34;&#34;Display the name and execution state of the current PolyScope program.&#34;&#34;&#34;
        try:
            response = rospy.ServiceProxy(self.services[&#39;program_state&#39;], GetProgramState)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(f&#39;Program &#34;{response.program_name}&#34; state is {response.state.state}&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to query if program is saved&#39;)
            self.logger.log_error(e)

    def terminate_external_control(self) -&gt; bool:
        &#34;&#34;&#34;Make the external_control node on PolyScope returns.&#34;&#34;&#34;
        success = self.trigger_service(&#39;hand_back_control&#39;)
        if success:
            self.logger.log_success(&#39;&#34;External Control&#34; program node terminated&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to terminate external control node&#39;)
            return False

    def get_loaded_program(self) -&gt; Union[str, None]:
        &#34;&#34;&#34;Returns the name of the loaded program.&#34;&#34;&#34;
        try:
            serv = self.services[&#39;get_loaded_program&#39;]
            response = rospy.ServiceProxy(serv, GetLoadedProgram)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.loaded_program = response.program_name
            return response.program_name
        except Exception as e:
            self.logger.log_error(&#39;Unable to request loaded program name&#39;)
            self.logger.log_error(str(e))

    def load_program(self, filename: str, ptype: str, wait: int = 10, attempts: int = 10) -&gt; None:
        &#34;&#34;&#34;Load a program or installation file.

        Args:
            filename (str): Name of file with extension e.g., program.urp
            ptype (str): Type of program. Accepting [&#39;prog&#39;, &#39;p&#39;, &#39;program&#39;, &#39;urp&#39;] or [&#39;inst&#39;, &#39;i&#39;, &#39;installation&#39;].
            wait (int, optional): Wait time to handle known disconnection issue. Defaults to 10.
            attempts (int, optional): Number of reconnection attempts. Defaults to 10.
        &#34;&#34;&#34;
        request = LoadRequest()
        request.filename = filename
        try:
            if ptype in [&#39;prog&#39;, &#39;p&#39;, &#39;program&#39;, &#39;urp&#39;]:
                serv = self.services[&#39;load_program&#39;]
            elif ptype in [&#39;inst&#39;, &#39;i&#39;, &#39;installation&#39;]:
                serv = self.services[&#39;load_installation&#39;]
            else:
                self.logger.log_error(f&#39;{ptype} is invalid&#39;)
                self.logger.log_error(f&#39;Expecting program [p, prog, program, urp] or installation [inst, i, installation]&#39;)
                return None
            rospy.wait_for_service(serv, timeout=self.service_timeout)
            response = rospy.ServiceProxy(serv, Load)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        except (ServiceException, ROSException) as _:
            self.logger.log_warn(&#39;Known dashboard server disconnection occured&#39;)
            self.logger.log_warn(f&#39;Waiting for {wait} seconds for program/installation to load correctly&#39;)
            rospy.sleep(wait)
            self.logger.log_warn(f&#39;Attempting to reconnect to dashboard server ({attempts} attempts)&#39;)
            self.spam_connect(attempts = attempts)
            self.close_popup()
            self.cold_boot()
        except KeyError as e:
            self.logger.log_error(str(e))
            return None
        self.last_known_installation = filename
        rospy.sleep(1)

    # ---------------------------------------------------------------------------- #
    #                                 ROBOT STATUS                                 #
    # ---------------------------------------------------------------------------- #

    def robot_status_callback(self, msg):
        self.robot_mode = msg.mode

    def robot_safety_callback(self, msg):
        self.safety_mode = msg.mode

    def robot_iostate_callback(self, msg):
        self.last_known_io_states = msg

    def get_robot_mode(self) -&gt; Union[int, None]:
        &#34;&#34;&#34;Returns the current robot mode.&#34;&#34;&#34;
        try:
            serv = self.services[&#39;get_robot_mode&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, GetRobotMode)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            mode = response.robot_mode.mode
            self.logger.log_success(f&#39;Robot mode = {mode} ({RobotModeMapping(mode).name})&#39;)
            return mode
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to request robot mode&#39;)
            self.logger.log_error(e)
        
    def get_safety_mode(self) -&gt; Union[int, None]:
        &#34;&#34;&#34;Returns the current safety mode.&#34;&#34;&#34;
        try:
            serv = self.services[&#39;get_safety_mode&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, GetSafetyMode)()
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            mode = response.safety_mode.mode
            self.logger.log_success(f&#39;Robot safety mode = {mode} ({SafetyModeMapping(mode).name})&#39;)
            return mode
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to request robot safety mode&#39;)
            self.logger.log_error(e)

    # ---------------------------------------------------------------------------- #
    #                               ADVANCED FEATURES                              #
    # ---------------------------------------------------------------------------- #

    def zero_force_torque_sensor(self) -&gt; bool:
        &#34;&#34;&#34;Zero the ft-sensor. Only work on e-Series in remote-control mode.&#34;&#34;&#34;
        success = self.trigger_service(&#39;zero_ftsensor&#39;)
        if success:
            self.logger.log_success(&#39;Force/Torque sensor zero-ed&#39;)
            return True
        else:
            self.logger.log_error(&#39;Unable to zero force/torque sensor&#39;)
            return False

    def log_to_pendant(self, message: str) -&gt; None:
        &#34;&#34;&#34;Log a message to PolyScope logs.&#34;&#34;&#34;
        request = AddToLogRequest()
        request.message = message
        try:
            serv = self.services[&#39;add_to_log&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, AddToLog)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to log message to Teach Pendant&#39;)
            self.logger.log_error(e)

    def raw_request(self, query):
        &#34;&#34;&#34;Send any arbitrary message or request to the dashboard server.&#34;&#34;&#34;
        request = RawRequestRequest()
        request.query = query
        try:
            serv = self.services[&#39;raw_request&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, RawRequest)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to log message to Teach Pendant&#39;)
            self.logger.log_error(e)

    def set_io(self, function: int, pin: int, state: float) -&gt; None:
        &#34;&#34;&#34;Set specific IO port on the robot. Currently not supporting specific domains (current/voltage).

        Args:
            function (int): See SetIOFunctionMapping.
            pin (int): Which pin to execute the function on.
            state (float): 0/1 for digital IOs and value for analog IO.
        &#34;&#34;&#34;
        request = SetIORequest()
        request.fun = function
        request.pin = pin
        request.state = state
        try:
            serv = self.services[&#39;set_io&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, SetIO)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(f&#39;Unable to set pin {pin} to {state} using {SetIOFunctionMapping(function).name}&#39;)
            self.logger.log_error(e)

    def set_payload(self, mass: float, cx: float, cy: float, cz: float) -&gt; None:
        &#34;&#34;&#34;Set the payload mass and center of gravity.

        Args:
            mass (float): Mass of the payload in kg.
            cx, cy, cz (float): Center of gravity of the payload.
        &#34;&#34;&#34;
        request = SetPayloadRequest()
        request.center_of_gravity = Vector3()
        request.center_of_gravity.x = cx
        request.center_of_gravity.y = cy
        request.center_of_gravity.z = cz
        request.mass = mass
        try:
            serv = self.services[&#39;set_payload&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, SetPayload)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(f&#39;Setting payload successfully&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to set payload&#39;)
            self.logger.log_error(e)

    def set_speed_slider(self, fraction: float) -&gt; None:
        &#34;&#34;&#34;Set robot execution speed as a fraction. Only set less than 1 on scaled controllers.

        Args:
            fraction (float): 0 to 1 if using scaled (default) controllers.
        &#34;&#34;&#34;
        request = SetSpeedSliderFractionRequest()
        request.speed_slider_fraction = clip(fraction, 0.0, 1.0)
        try:
            serv = self.services[&#39;set_speed_slider&#39;]
            rospy.wait_for_service(serv, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv, SetSpeedSliderFraction)(request)
            if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
            self.logger.log_success(f&#39;Setting speed slider successfully&#39;)
        except (ROSException, ServiceException, KeyError) as e:
            self.logger.log_error(&#39;Unable to set speed slider&#39;)
            self.logger.log_error(e)

    # def set_robot_mode(self):
    #     raise NotImplementedError

    # ---------------------------------------------------------------------------- #
    #                             SUPPORTING FUNCTIONS                             #
    # ---------------------------------------------------------------------------- #

    def trigger_service(self, serv_alias):
        &#34;&#34;&#34;Internal trigger service handling with exceptions&#34;&#34;&#34;
        if serv_alias in self.services:
            serv_name = self.services[serv_alias]
            try:
                rospy.wait_for_service(serv_name, timeout = self.service_timeout)
                response = rospy.ServiceProxy(serv_name, Trigger)()
                if not response.success:
                    self.logger.log_error(response.message)
                    raise ServiceException(&#39;response.success returned False&#39;)
                return response.success
            except (ROSException, ROSInterruptException, KeyboardInterrupt, ServiceException) as e:
                self.logger.log_error(f&#39;Unable to trigger {serv_name}&#39;)
                self.logger.log_error(e)
        else:
            self.logger.log_error(f&#39;{serv_alias} is unknown/unsupported. Aborted.&#39;)
            return False

    def define_services(self):
        available = rosservice.get_service_list()
        filterted = [s for s in available if &#39;ur_hardware_interface&#39; in s and &#39;logger&#39; not in s]
        services = {s[s.rfind(&#39;/&#39;) + 1:] : s for s in filterted}
        return dict(sorted(services.items()))

    def register_robot_status(self) -&gt; None:
        &#34;&#34;&#34;Register necessary subscribers and callbacks to monitor robot operational status.&#34;&#34;&#34;
        try:
            # wait for topics to show up
            self.robot_mode = rospy.wait_for_message(&#39;/ur_hardware_interface/robot_mode&#39;, RobotMode, timeout = self.service_timeout).mode
            self.safety_mode = rospy.wait_for_message(&#39;/ur_hardware_interface/safety_mode&#39;, SafetyMode, timeout = self.service_timeout).mode
            self.last_known_io_states = rospy.wait_for_message(&#39;/ur_hardware_interface/io_states&#39;, IOStates, timeout = self.service_timeout)

            # register robot status tracking with callbacks
            self.robot_mode_sub = rospy.Subscriber(&#39;/ur_hardware_interface/robot_mode&#39;, RobotMode, self.robot_status_callback)
            self.robot_safety_sub = rospy.Subscriber(&#39;/ur_hardware_interface/safety&#39;, SafetyMode, self.robot_safety_callback)
            self.robot_io_sub = rospy.Subscriber(&#39;/ur_hardware_interface/io_states&#39;, IOStates, self.robot_iostate_callback)

            # verify if services are available
            self.verify_services()

            # get program name
            self.get_loaded_program()

            self.logger.log_success(&#39;Registered robot status subscribers&#39;)
        except ROSException as error:
            self.logger.log_error(&#39;Unable to register status subscriber&#39;)
            self.logger.log_error(&#39;Remote Dashboard terminated&#39;)
            self.logger.log_error(error)
            exit(-1)

    def verify_services(self):
        self.logger.log_warn(&#39;Validating if all services are available&#39;)
        for _, serv in self.services.items():
            rospy.wait_for_service(serv, timeout = self.service_timeout)
        self.logger.log_success(&#39;All supported services are available&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.clear_operational_mode"><code class="name flex">
<span>def <span class="ident">clear_operational_mode</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Allow PolyScope to change operational mode. User password will be enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_operational_mode(self) -&gt; bool:
    &#34;&#34;&#34;Allow PolyScope to change operational mode. User password will be enabled.&#34;&#34;&#34;
    success = self.trigger_service(&#39;clear_operational_mode&#39;)
    if success:
        self.logger.log_warn(f&#39;Operational mode cleared&#39;)
        return True
    else:
        self.logger.log_error(&#39;Unable to clear operational mode&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.clear_protective_stop"><code class="name flex">
<span>def <span class="ident">clear_protective_stop</span></span>(<span>self, timeout: int = 30) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Clear a protective stop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_protective_stop(self, timeout: int = 30) -&gt; bool:
    &#34;&#34;&#34;Clear a protective stop.&#34;&#34;&#34;
    success = self.trigger_service(&#39;unlock_protective_stop&#39;)
    if success:
        self.logger.log_warn(f&#39;Waiting for protective stop to clear&#39;)
        try:
            elapsed = 0
            while self.safety_mode != 1 and elapsed &lt; timeout and not rospy.is_shutdown():
                rospy.sleep(1)
                elapsed += 1
                if elapsed &gt; timeout:
                    raise ROSException
            self.logger.log_success(&#39;Protective stop cleared&#39;)
            return True
        except ROSException as _:
            self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds clearing time. Aborted.&#39;)
            return False
    else:
        self.logger.log_error(&#39;Unable to clear protective stop&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.close_popup"><code class="name flex">
<span>def <span class="ident">close_popup</span></span>(<span>self, safety: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Close a popup on the Teach Pendant or PolyScope.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>safety</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set to True if popup is a safety popup. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the targeted popup is closed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_popup(self, safety: bool = False) -&gt; bool:
    &#34;&#34;&#34;Close a popup on the Teach Pendant or PolyScope.

    Args:
        safety (bool, optional): Set to True if popup is a safety popup. Defaults to False.

    Returns:
        bool: True if the targeted popup is closed.
    &#34;&#34;&#34;
    if safety:
        success = self.trigger_service(&#39;close_safety_popup&#39;)
    else:
        success = self.trigger_service(&#39;close_popup&#39;)

    if success:
        self.logger.log_success(f&#39;{&#34;Safety popup&#34; if safety else &#34;Popup&#34;} closed&#39;)
        return True
    else:
        self.logger.log_error(&#39;Unable to close popup&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.cold_boot"><code class="name flex">
<span>def <span class="ident">cold_boot</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Go directly to operational state (power on, brakes released). See release_brakes().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cold_boot(self) -&gt; bool:
    &#34;&#34;&#34;Go directly to operational state (power on, brakes released). See release_brakes().&#34;&#34;&#34;
    return self.release_brakes()</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.connect_dashboard"><code class="name flex">
<span>def <span class="ident">connect_dashboard</span></span>(<span>self, quiet: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the dashboard server. Need to be done before calling other services.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_dashboard(self, quiet: bool = False) -&gt; bool:
    &#34;&#34;&#34;Connect to the dashboard server. Need to be done before calling other services.&#34;&#34;&#34;
    success = self.trigger_service(&#39;connect&#39;)
    if success:
        self.logger.log_success(&#39;Connection to dashboard established&#39;)
        return True
    else:
        if not quiet:
            self.logger.log_error(&#39;Unable to disconnect from dashboard server&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.define_services"><code class="name flex">
<span>def <span class="ident">define_services</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_services(self):
    available = rosservice.get_service_list()
    filterted = [s for s in available if &#39;ur_hardware_interface&#39; in s and &#39;logger&#39; not in s]
    services = {s[s.rfind(&#39;/&#39;) + 1:] : s for s in filterted}
    return dict(sorted(services.items()))</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.disconnect_dashboard"><code class="name flex">
<span>def <span class="ident">disconnect_dashboard</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from the dashboard server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_dashboard(self) -&gt; bool:
    &#34;&#34;&#34;Disconnect from the dashboard server.&#34;&#34;&#34;
    success = self.trigger_service(&#39;quit&#39;)
    if success:
        self.logger.log_success(&#39;Connection to dashboard terminated&#39;)
        return True
    else:
        self.logger.log_error(&#39;Unable to disconnect from dashboard server&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_loaded_program"><code class="name flex">
<span>def <span class="ident">get_loaded_program</span></span>(<span>self) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the loaded program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_loaded_program(self) -&gt; Union[str, None]:
    &#34;&#34;&#34;Returns the name of the loaded program.&#34;&#34;&#34;
    try:
        serv = self.services[&#39;get_loaded_program&#39;]
        response = rospy.ServiceProxy(serv, GetLoadedProgram)()
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        self.loaded_program = response.program_name
        return response.program_name
    except Exception as e:
        self.logger.log_error(&#39;Unable to request loaded program name&#39;)
        self.logger.log_error(str(e))</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_robot_mode"><code class="name flex">
<span>def <span class="ident">get_robot_mode</span></span>(<span>self) ‑> Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current robot mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_robot_mode(self) -&gt; Union[int, None]:
    &#34;&#34;&#34;Returns the current robot mode.&#34;&#34;&#34;
    try:
        serv = self.services[&#39;get_robot_mode&#39;]
        rospy.wait_for_service(serv, timeout = self.service_timeout)
        response = rospy.ServiceProxy(serv, GetRobotMode)()
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        mode = response.robot_mode.mode
        self.logger.log_success(f&#39;Robot mode = {mode} ({RobotModeMapping(mode).name})&#39;)
        return mode
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to request robot mode&#39;)
        self.logger.log_error(e)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_safety_mode"><code class="name flex">
<span>def <span class="ident">get_safety_mode</span></span>(<span>self) ‑> Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current safety mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_safety_mode(self) -&gt; Union[int, None]:
    &#34;&#34;&#34;Returns the current safety mode.&#34;&#34;&#34;
    try:
        serv = self.services[&#39;get_safety_mode&#39;]
        rospy.wait_for_service(serv, timeout = self.service_timeout)
        response = rospy.ServiceProxy(serv, GetSafetyMode)()
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        mode = response.safety_mode.mode
        self.logger.log_success(f&#39;Robot safety mode = {mode} ({SafetyModeMapping(mode).name})&#39;)
        return mode
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to request robot safety mode&#39;)
        self.logger.log_error(e)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.is_program_running"><code class="name flex">
<span>def <span class="ident">is_program_running</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the default or loaded program is running.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_program_running(self) -&gt; bool:
    &#34;&#34;&#34;Returns true if the default or loaded program is running.&#34;&#34;&#34;
    try:
        response = rospy.ServiceProxy(self.services[&#39;program_running&#39;], IsProgramRunning)()
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        self.logger.log_success(f&#39;Program &#34;{self.loaded_program}&#34; is {&#34;running&#34; if response.program_running else &#34;not running&#34;}&#39;)
        return response.program_running
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to query if program is running&#39;)
        self.logger.log_error(e)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.is_program_saved"><code class="name flex">
<span>def <span class="ident">is_program_saved</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the default or loaded program is saved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_program_saved(self) -&gt; bool:
    &#34;&#34;&#34;Returns true if the default or loaded program is saved.&#34;&#34;&#34;
    try:
        response = rospy.ServiceProxy(self.services[&#39;program_saved&#39;], IsProgramSaved)()
        self.logger.log_success(f&#39;Program &#34;{response.program_name}&#34; is {&#34;saved&#34; if response.program_saved else &#34;not saved&#34;}&#39;)
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        return response.program_saved
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to query if program is saved&#39;)
        self.logger.log_error(e)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.load_program"><code class="name flex">
<span>def <span class="ident">load_program</span></span>(<span>self, filename: str, ptype: str, wait: int = 10, attempts: int = 10) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Load a program or installation file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of file with extension e.g., program.urp</dd>
<dt><strong><code>ptype</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of program. Accepting ['prog', 'p', 'program', 'urp'] or ['inst', 'i', 'installation'].</dd>
<dt><strong><code>wait</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Wait time to handle known disconnection issue. Defaults to 10.</dd>
<dt><strong><code>attempts</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of reconnection attempts. Defaults to 10.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_program(self, filename: str, ptype: str, wait: int = 10, attempts: int = 10) -&gt; None:
    &#34;&#34;&#34;Load a program or installation file.

    Args:
        filename (str): Name of file with extension e.g., program.urp
        ptype (str): Type of program. Accepting [&#39;prog&#39;, &#39;p&#39;, &#39;program&#39;, &#39;urp&#39;] or [&#39;inst&#39;, &#39;i&#39;, &#39;installation&#39;].
        wait (int, optional): Wait time to handle known disconnection issue. Defaults to 10.
        attempts (int, optional): Number of reconnection attempts. Defaults to 10.
    &#34;&#34;&#34;
    request = LoadRequest()
    request.filename = filename
    try:
        if ptype in [&#39;prog&#39;, &#39;p&#39;, &#39;program&#39;, &#39;urp&#39;]:
            serv = self.services[&#39;load_program&#39;]
        elif ptype in [&#39;inst&#39;, &#39;i&#39;, &#39;installation&#39;]:
            serv = self.services[&#39;load_installation&#39;]
        else:
            self.logger.log_error(f&#39;{ptype} is invalid&#39;)
            self.logger.log_error(f&#39;Expecting program [p, prog, program, urp] or installation [inst, i, installation]&#39;)
            return None
        rospy.wait_for_service(serv, timeout=self.service_timeout)
        response = rospy.ServiceProxy(serv, Load)(request)
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
    except (ServiceException, ROSException) as _:
        self.logger.log_warn(&#39;Known dashboard server disconnection occured&#39;)
        self.logger.log_warn(f&#39;Waiting for {wait} seconds for program/installation to load correctly&#39;)
        rospy.sleep(wait)
        self.logger.log_warn(f&#39;Attempting to reconnect to dashboard server ({attempts} attempts)&#39;)
        self.spam_connect(attempts = attempts)
        self.close_popup()
        self.cold_boot()
    except KeyError as e:
        self.logger.log_error(str(e))
        return None
    self.last_known_installation = filename
    rospy.sleep(1)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.log_to_pendant"><code class="name flex">
<span>def <span class="ident">log_to_pendant</span></span>(<span>self, message: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Log a message to PolyScope logs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_to_pendant(self, message: str) -&gt; None:
    &#34;&#34;&#34;Log a message to PolyScope logs.&#34;&#34;&#34;
    request = AddToLogRequest()
    request.message = message
    try:
        serv = self.services[&#39;add_to_log&#39;]
        rospy.wait_for_service(serv, timeout = self.service_timeout)
        response = rospy.ServiceProxy(serv, AddToLog)(request)
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to log message to Teach Pendant&#39;)
        self.logger.log_error(e)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.pause_loaded_program"><code class="name flex">
<span>def <span class="ident">pause_loaded_program</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Pause PolyScope program execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pause_loaded_program(self) -&gt; bool:
    &#34;&#34;&#34;Pause PolyScope program execution.&#34;&#34;&#34;
    success = self.trigger_service(&#39;pause&#39;)
    if success:
        self.logger.log_success(f&#39;Program {self.loaded_program} is paused&#39;)
        return True
    else:
        self.logger.log_error(f&#39;Unable to pause {self.loaded_program}&#39;)

        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.power_off_arm"><code class="name flex">
<span>def <span class="ident">power_off_arm</span></span>(<span>self, timeout: int = 30) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Power off the arm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_off_arm(self, timeout: int = 30) -&gt; bool:
    &#34;&#34;&#34;Power off the arm.&#34;&#34;&#34;
    success = self.trigger_service(&#39;power_off&#39;)
    if success:
        self.logger.log_warn(f&#39;Waiting for arm to power off&#39;)
        try:
            elapsed = 0
            while self.robot_mode &gt; 3 and elapsed &lt; timeout and not rospy.is_shutdown():
                rospy.sleep(1)
                elapsed += 1
                if elapsed &gt; timeout:
                    raise ROSException
            self.logger.log_success(&#39;Arm powered off&#39;)
            return True
        except ROSException as e:
            self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds power off time. Aborted.&#39;)
            return False
    else:
        self.logger.log_error(&#39;Unable to power off robot arm&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.power_on_arm"><code class="name flex">
<span>def <span class="ident">power_on_arm</span></span>(<span>self, timeout: int = 30) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Power on the arm to idle state (brakes engaged).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_on_arm(self, timeout: int = 30) -&gt; bool:
    &#34;&#34;&#34;Power on the arm to idle state (brakes engaged).&#34;&#34;&#34;
    success = self.trigger_service(&#39;power_on&#39;)
    if success:
        self.logger.log_warn(f&#39;Waiting for arm to power on&#39;)
        try:
            elapsed = 0
            while self.robot_mode &lt; 5 and elapsed &lt; timeout and not rospy.is_shutdown():
                rospy.sleep(1)
                elapsed += 1
                if elapsed &gt; timeout:
                    raise ROSException
            self.logger.log_success(&#39;Arm powered on (brakes engaged)&#39;)
            return True
        except ROSException as e:
            self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds power on time. Aborted.&#39;)
            return False
    else:
        self.logger.log_error(&#39;Unable to power on robot arm&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.query_program_state"><code class="name flex">
<span>def <span class="ident">query_program_state</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Display the name and execution state of the current PolyScope program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_program_state(self) -&gt; None:
    &#34;&#34;&#34;Display the name and execution state of the current PolyScope program.&#34;&#34;&#34;
    try:
        response = rospy.ServiceProxy(self.services[&#39;program_state&#39;], GetProgramState)()
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        self.logger.log_success(f&#39;Program &#34;{response.program_name}&#34; state is {response.state.state}&#39;)
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to query if program is saved&#39;)
        self.logger.log_error(e)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.raw_request"><code class="name flex">
<span>def <span class="ident">raw_request</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<div class="desc"><p>Send any arbitrary message or request to the dashboard server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raw_request(self, query):
    &#34;&#34;&#34;Send any arbitrary message or request to the dashboard server.&#34;&#34;&#34;
    request = RawRequestRequest()
    request.query = query
    try:
        serv = self.services[&#39;raw_request&#39;]
        rospy.wait_for_service(serv, timeout = self.service_timeout)
        response = rospy.ServiceProxy(serv, RawRequest)(request)
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to log message to Teach Pendant&#39;)
        self.logger.log_error(e)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.register_robot_status"><code class="name flex">
<span>def <span class="ident">register_robot_status</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Register necessary subscribers and callbacks to monitor robot operational status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_robot_status(self) -&gt; None:
    &#34;&#34;&#34;Register necessary subscribers and callbacks to monitor robot operational status.&#34;&#34;&#34;
    try:
        # wait for topics to show up
        self.robot_mode = rospy.wait_for_message(&#39;/ur_hardware_interface/robot_mode&#39;, RobotMode, timeout = self.service_timeout).mode
        self.safety_mode = rospy.wait_for_message(&#39;/ur_hardware_interface/safety_mode&#39;, SafetyMode, timeout = self.service_timeout).mode
        self.last_known_io_states = rospy.wait_for_message(&#39;/ur_hardware_interface/io_states&#39;, IOStates, timeout = self.service_timeout)

        # register robot status tracking with callbacks
        self.robot_mode_sub = rospy.Subscriber(&#39;/ur_hardware_interface/robot_mode&#39;, RobotMode, self.robot_status_callback)
        self.robot_safety_sub = rospy.Subscriber(&#39;/ur_hardware_interface/safety&#39;, SafetyMode, self.robot_safety_callback)
        self.robot_io_sub = rospy.Subscriber(&#39;/ur_hardware_interface/io_states&#39;, IOStates, self.robot_iostate_callback)

        # verify if services are available
        self.verify_services()

        # get program name
        self.get_loaded_program()

        self.logger.log_success(&#39;Registered robot status subscribers&#39;)
    except ROSException as error:
        self.logger.log_error(&#39;Unable to register status subscriber&#39;)
        self.logger.log_error(&#39;Remote Dashboard terminated&#39;)
        self.logger.log_error(error)
        exit(-1)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.release_brakes"><code class="name flex">
<span>def <span class="ident">release_brakes</span></span>(<span>self, timeout: int = 30) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Fully power on the robot with brakes released.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release_brakes(self, timeout: int = 30) -&gt; bool:
    &#34;&#34;&#34;Fully power on the robot with brakes released.&#34;&#34;&#34;
    success = self.trigger_service(&#39;brake_release&#39;)
    if success:
        self.logger.log_warn(f&#39;Waiting for arm to power on and release brakes&#39;)
        try:
            elapsed = 0
            while self.robot_mode &lt; 7 and elapsed &lt; timeout and not rospy.is_shutdown():
                rospy.sleep(1)
                elapsed += 1
                if elapsed &gt; timeout:
                    raise ROSException
            self.logger.log_success(&#39;Arm powered and ready for planning!&#39;)
            return True
        except ROSException as _:
            self.logger.log_error(f&#39;Wait time exceeded {timeout} seconds full powered on time. Aborted.&#39;)
            return False
    else:
        self.logger.log_error(&#39;Unable to fully initialized robot&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.restart_safety"><code class="name flex">
<span>def <span class="ident">restart_safety</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Clear a safety fault or violation. Arm will be powered off.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restart_safety(self) -&gt; bool:
    &#34;&#34;&#34;Clear a safety fault or violation. Arm will be powered off.&#34;&#34;&#34;
    success = self.trigger_service(&#39;restart_safety&#39;)
    if success:
        self.logger.log_warn(f&#39;Safety fault/violation cleared&#39;)
        self.logger.log_warn(f&#39;Robot is now powered off&#39;)
        self.logger.log_error(f&#39;Check log for additional information before restarting!&#39;)
        return True
    else:
        self.logger.log_error(&#39;Unable to clear safety violation&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_iostate_callback"><code class="name flex">
<span>def <span class="ident">robot_iostate_callback</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def robot_iostate_callback(self, msg):
    self.last_known_io_states = msg</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_safety_callback"><code class="name flex">
<span>def <span class="ident">robot_safety_callback</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def robot_safety_callback(self, msg):
    self.safety_mode = msg.mode</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_status_callback"><code class="name flex">
<span>def <span class="ident">robot_status_callback</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def robot_status_callback(self, msg):
    self.robot_mode = msg.mode</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.send_popup"><code class="name flex">
<span>def <span class="ident">send_popup</span></span>(<span>self, message: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Send a message as a popup to Teach Pendant or PolyScope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_popup(self, message: str) -&gt; bool:
    &#34;&#34;&#34;Send a message as a popup to Teach Pendant or PolyScope.&#34;&#34;&#34;
    request = PopupRequest()
    request.message = message
    try:
        serv = self.services[&#39;popup&#39;]
        rospy.wait_for_message(serv, timeout = self.service_timeout)
        response = rospy.ServiceProxy(serv, Popup)(request)
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        self.logger.log_success(&#39;Popup sent to Teach Pendant&#39;)
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to send popup&#39;)
        self.logger.log_error(e)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_io"><code class="name flex">
<span>def <span class="ident">set_io</span></span>(<span>self, function: int, pin: int, state: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set specific IO port on the robot. Currently not supporting specific domains (current/voltage).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>int</code></dt>
<dd>See SetIOFunctionMapping.</dd>
<dt><strong><code>pin</code></strong> :&ensp;<code>int</code></dt>
<dd>Which pin to execute the function on.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>float</code></dt>
<dd>0/1 for digital IOs and value for analog IO.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_io(self, function: int, pin: int, state: float) -&gt; None:
    &#34;&#34;&#34;Set specific IO port on the robot. Currently not supporting specific domains (current/voltage).

    Args:
        function (int): See SetIOFunctionMapping.
        pin (int): Which pin to execute the function on.
        state (float): 0/1 for digital IOs and value for analog IO.
    &#34;&#34;&#34;
    request = SetIORequest()
    request.fun = function
    request.pin = pin
    request.state = state
    try:
        serv = self.services[&#39;set_io&#39;]
        rospy.wait_for_service(serv, timeout = self.service_timeout)
        response = rospy.ServiceProxy(serv, SetIO)(request)
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(f&#39;Unable to set pin {pin} to {state} using {SetIOFunctionMapping(function).name}&#39;)
        self.logger.log_error(e)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_payload"><code class="name flex">
<span>def <span class="ident">set_payload</span></span>(<span>self, mass: float, cx: float, cy: float, cz: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the payload mass and center of gravity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mass</code></strong> :&ensp;<code>float</code></dt>
<dd>Mass of the payload in kg.</dd>
</dl>
<p>cx, cy, cz (float): Center of gravity of the payload.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_payload(self, mass: float, cx: float, cy: float, cz: float) -&gt; None:
    &#34;&#34;&#34;Set the payload mass and center of gravity.

    Args:
        mass (float): Mass of the payload in kg.
        cx, cy, cz (float): Center of gravity of the payload.
    &#34;&#34;&#34;
    request = SetPayloadRequest()
    request.center_of_gravity = Vector3()
    request.center_of_gravity.x = cx
    request.center_of_gravity.y = cy
    request.center_of_gravity.z = cz
    request.mass = mass
    try:
        serv = self.services[&#39;set_payload&#39;]
        rospy.wait_for_service(serv, timeout = self.service_timeout)
        response = rospy.ServiceProxy(serv, SetPayload)(request)
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        self.logger.log_success(f&#39;Setting payload successfully&#39;)
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to set payload&#39;)
        self.logger.log_error(e)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_speed_slider"><code class="name flex">
<span>def <span class="ident">set_speed_slider</span></span>(<span>self, fraction: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set robot execution speed as a fraction. Only set less than 1 on scaled controllers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fraction</code></strong> :&ensp;<code>float</code></dt>
<dd>0 to 1 if using scaled (default) controllers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_speed_slider(self, fraction: float) -&gt; None:
    &#34;&#34;&#34;Set robot execution speed as a fraction. Only set less than 1 on scaled controllers.

    Args:
        fraction (float): 0 to 1 if using scaled (default) controllers.
    &#34;&#34;&#34;
    request = SetSpeedSliderFractionRequest()
    request.speed_slider_fraction = clip(fraction, 0.0, 1.0)
    try:
        serv = self.services[&#39;set_speed_slider&#39;]
        rospy.wait_for_service(serv, timeout = self.service_timeout)
        response = rospy.ServiceProxy(serv, SetSpeedSliderFraction)(request)
        if not response.success: raise ServiceException(&#39;response.success returned False&#39;)
        self.logger.log_success(f&#39;Setting speed slider successfully&#39;)
    except (ROSException, ServiceException, KeyError) as e:
        self.logger.log_error(&#39;Unable to set speed slider&#39;)
        self.logger.log_error(e)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.spam_connect"><code class="name flex">
<span>def <span class="ident">spam_connect</span></span>(<span>self, attempts: int = 10) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Repeatedly calling connect() due to error prone and asynchronous status of the server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attempts</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of times connect() is called internally. Defaults to 10.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spam_connect(self, attempts: int = 10) -&gt; bool:
    &#34;&#34;&#34;Repeatedly calling connect() due to error prone and asynchronous status of the server.
    
    Args:
        attempts (int, optional): Number of times connect() is called internally. Defaults to 10.
    &#34;&#34;&#34;
    for i in range(attempts):
        self.logger.log_warn(f&#39;Reconnecting attempted ({attempts - i} remaining)&#39;, indent = 1)
        if self.connect_dashboard(quiet = True):
            return True
        rospy.sleep(1)
    self.logger.log_error(&#39;Reconnection attempts to dashboard server unsuccessful&#39;)
    return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.start_loaded_program"><code class="name flex">
<span>def <span class="ident">start_loaded_program</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Start execution of default or loaded program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_loaded_program(self) -&gt; bool:
    &#34;&#34;&#34;Start execution of default or loaded program.&#34;&#34;&#34;
    success = self.trigger_service(&#39;play&#39;)
    if success:
        self.logger.log_success(f&#39;Program {self.loaded_program} is running&#39;)
        return True
    else:
        self.logger.log_error(f&#39;Unable to start {self.loaded_program}&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.stop_loaded_program"><code class="name flex">
<span>def <span class="ident">stop_loaded_program</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Stop PolyScope program execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_loaded_program(self) -&gt; bool:
    &#34;&#34;&#34;Stop PolyScope program execution.&#34;&#34;&#34;
    success = self.trigger_service(&#39;stop&#39;)
    if success:
        self.logger.log_success(f&#39;Program {self.loaded_program} is stopped&#39;)
        return True
    else:
        self.logger.log_error(f&#39;Unable to stop {self.loaded_program}&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.system_shutdown"><code class="name flex">
<span>def <span class="ident">system_shutdown</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Fully power down the robot (including control box).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_shutdown(self) -&gt; None:
    &#34;&#34;&#34;Fully power down the robot (including control box).&#34;&#34;&#34;
    _ = self.trigger_service(&#39;shutdown&#39;)
    # rospy.signal_shutdown(&#39;UR System shutdown requested. Shutting everything down.&#39;)
    self.logger.log_success(&#39;Goodbye!&#39;)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.terminate_external_control"><code class="name flex">
<span>def <span class="ident">terminate_external_control</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Make the external_control node on PolyScope returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminate_external_control(self) -&gt; bool:
    &#34;&#34;&#34;Make the external_control node on PolyScope returns.&#34;&#34;&#34;
    success = self.trigger_service(&#39;hand_back_control&#39;)
    if success:
        self.logger.log_success(&#39;&#34;External Control&#34; program node terminated&#39;)
        return True
    else:
        self.logger.log_error(&#39;Unable to terminate external control node&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.trigger_service"><code class="name flex">
<span>def <span class="ident">trigger_service</span></span>(<span>self, serv_alias)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal trigger service handling with exceptions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_service(self, serv_alias):
    &#34;&#34;&#34;Internal trigger service handling with exceptions&#34;&#34;&#34;
    if serv_alias in self.services:
        serv_name = self.services[serv_alias]
        try:
            rospy.wait_for_service(serv_name, timeout = self.service_timeout)
            response = rospy.ServiceProxy(serv_name, Trigger)()
            if not response.success:
                self.logger.log_error(response.message)
                raise ServiceException(&#39;response.success returned False&#39;)
            return response.success
        except (ROSException, ROSInterruptException, KeyboardInterrupt, ServiceException) as e:
            self.logger.log_error(f&#39;Unable to trigger {serv_name}&#39;)
            self.logger.log_error(e)
    else:
        self.logger.log_error(f&#39;{serv_alias} is unknown/unsupported. Aborted.&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.verify_services"><code class="name flex">
<span>def <span class="ident">verify_services</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_services(self):
    self.logger.log_warn(&#39;Validating if all services are available&#39;)
    for _, serv in self.services.items():
        rospy.wait_for_service(serv, timeout = self.service_timeout)
    self.logger.log_success(&#39;All supported services are available&#39;)</code></pre>
</details>
</dd>
<dt id="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.zero_force_torque_sensor"><code class="name flex">
<span>def <span class="ident">zero_force_torque_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Zero the ft-sensor. Only work on e-Series in remote-control mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zero_force_torque_sensor(self) -&gt; bool:
    &#34;&#34;&#34;Zero the ft-sensor. Only work on e-Series in remote-control mode.&#34;&#34;&#34;
    success = self.trigger_service(&#39;zero_ftsensor&#39;)
    if success:
        self.logger.log_success(&#39;Force/Torque sensor zero-ed&#39;)
        return True
    else:
        self.logger.log_error(&#39;Unable to zero force/torque sensor&#39;)
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rvl_ur_remote_dashboard" href="index.html">rvl_ur_remote_dashboard</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard">URRemoteDashboard</a></code></h4>
<ul class="">
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.clear_operational_mode" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.clear_operational_mode">clear_operational_mode</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.clear_protective_stop" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.clear_protective_stop">clear_protective_stop</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.close_popup" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.close_popup">close_popup</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.cold_boot" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.cold_boot">cold_boot</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.connect_dashboard" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.connect_dashboard">connect_dashboard</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.define_services" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.define_services">define_services</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.disconnect_dashboard" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.disconnect_dashboard">disconnect_dashboard</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_loaded_program" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_loaded_program">get_loaded_program</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_robot_mode" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_robot_mode">get_robot_mode</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_safety_mode" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.get_safety_mode">get_safety_mode</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.is_program_running" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.is_program_running">is_program_running</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.is_program_saved" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.is_program_saved">is_program_saved</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.load_program" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.load_program">load_program</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.log_to_pendant" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.log_to_pendant">log_to_pendant</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.pause_loaded_program" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.pause_loaded_program">pause_loaded_program</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.power_off_arm" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.power_off_arm">power_off_arm</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.power_on_arm" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.power_on_arm">power_on_arm</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.query_program_state" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.query_program_state">query_program_state</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.raw_request" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.raw_request">raw_request</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.register_robot_status" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.register_robot_status">register_robot_status</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.release_brakes" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.release_brakes">release_brakes</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.restart_safety" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.restart_safety">restart_safety</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_iostate_callback" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_iostate_callback">robot_iostate_callback</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_safety_callback" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_safety_callback">robot_safety_callback</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_status_callback" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.robot_status_callback">robot_status_callback</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.send_popup" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.send_popup">send_popup</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_io" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_io">set_io</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_payload" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_payload">set_payload</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_speed_slider" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.set_speed_slider">set_speed_slider</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.spam_connect" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.spam_connect">spam_connect</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.start_loaded_program" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.start_loaded_program">start_loaded_program</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.stop_loaded_program" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.stop_loaded_program">stop_loaded_program</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.system_shutdown" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.system_shutdown">system_shutdown</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.terminate_external_control" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.terminate_external_control">terminate_external_control</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.trigger_service" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.trigger_service">trigger_service</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.verify_services" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.verify_services">verify_services</a></code></li>
<li><code><a title="rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.zero_force_torque_sensor" href="#rvl_ur_remote_dashboard.URRemoteDashboard.URRemoteDashboard.zero_force_torque_sensor">zero_force_torque_sensor</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>